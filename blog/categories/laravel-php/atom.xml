<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Laravel,php | Friparia Blog]]></title>
  <link href="http://friparia.github.io/blog/categories/laravel-php/atom.xml" rel="self"/>
  <link href="http://friparia.github.io/"/>
  <updated>2014-05-26T14:14:18+08:00</updated>
  <id>http://friparia.github.io/</id>
  <author>
    <name><![CDATA[Friparia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Laravel 命令行开发入门]]></title>
    <link href="http://friparia.github.io/blog/2014/05/17/laravel-command-line-walkthrough/"/>
    <updated>2014-05-17T23:08:46+08:00</updated>
    <id>http://friparia.github.io/blog/2014/05/17/laravel-command-line-walkthrough</id>
    <content type="html"><![CDATA[<p>上一篇我们试过了Laravel中的包开发，我们可以创建自己的包，并且复用他们，来很快的构建我们的应用，这一次我们来简要介绍一下Laravel中另一个强大的功能，Artisan命令行，当然，文档是一切的基础<a href="http://www.golaravel.com/docs/4.1/commands/">中文文档</a>，这个可能稍微有点过时，如生成使得<code>--bench</code>的参数在新版本中就已经去掉了，所以看<a href="https://www.laravel.com/">英文文档</a>是一个不错的选择<br>
&lt;!--more--&gt;</p>

<h1>准备</h1>

<p>所有的新东西都得需要曾经的基础，首先的基础就是Laravel的开发的基础了，如果使用过命令行，比如数据库迁移命令的话会更好的理解。应用命令行我们能够更好更快的构建我们的应用，或者对我们的应用进行一些命令行的操作。</p>

<h1>创建</h1>

<p>我们可能有两种不同的命令行开发，一种是在应用中的，可以简单的理解为我们的代码都是写在<code>app/commands</code>这个目录下的，另一种是在开发的包中的，也可以理解为我们所写的命令行代码是在<code>workbench/vendor/package/src/Vendor/Package/</code>文件中的，区别我们稍后会提到。</p>

<p>运行<code>php artisan command:make YourCommand</code>就可以创建一个命令了，默认是创建在你的应用中，即<code>app/commands</code>这个目录中，而如果我们需要创建在自己开发的包中的命令的话，我们就需要加上<code>--path=workbench/vendor/package/src/Vendor/Package</code>这个参数，这样我们创建的命令才可以随着包的发布而进行使用了。</p>

<h1>实现</h1>

<p>用命令行就可以搭一个很不错的架子出来，我们可以打开生成的<code>workbench/vendor/package/src/commands/YourCommand.php</code>这个文件，来完成我们具体的命令实现。<br>
由于<code>--bench</code>参数不再支持，所以我们手动在开始加入<br>
<code>php<br>
namespace Vendor\Package;<br>
</code></p>

<p>这一行，使得我们的包能够找到所对应的命令。</p>

<p>在<code>YourCommand</code>这个类中我们可以看到这几个方法:</p>

<ul>
<li><code>__consruct()</code>，当然这个是默认的构造函数没什么可说的</li>
<li><code>fire()</code>， 这个函数是在我们运行命令的时候所执行的函数，即我们需要实现的具体逻辑代码就是写在这个里面的</li>
<li><code>getArguments()</code>和<code>getOptions()</code>是得到命令的参数和选项，如果有参数设置的需要，我们可以通过<code>$this-&gt;argument(&#39;name&#39;)</code>和<code>$this-&gt;option(&#39;name&#39;)</code>来获得我们所需要的参数。
同时还有两个属性:</li>
<li><code>$name</code>，是这个命令的名字，即在命令行中所敲的</li>
<li><code>$description</code>，是这个命令的描述，会对这个命令进行一个简要的描述</li>
</ul>

<p>了解了这些之后我们就可以完成我们的<code>fire()</code>函数了，我们可能用得到的输出函数<code>info</code>,<code>comment</code>,<code>question</code>,<code>error</code>等可以以一种简单的方式使用。<br>
比如我们在刚开始询问是否生成，就可以写下以下代码:</p>

<p><code>php<br>
if($this-&gt;confirm(&#39;确定生成?[Y|N]){<br>
  $this-&gt;info(&#39;生成中....&#39;);<br>
}<br>
</code></p>

<p>这样我们就能够写出我们的具体的命令了，下面我们以一个压缩assets的命令例子来详细叙述整个包命令开发的过程</p>

<h1>例子</h1>

<p>首先按照<a href="http://www.friparia.com/blog/2014/04/18/laravel-package-develop-walkthrough/">包生成</a>来生成一个assetcompress的包，然后执行<code>command:make</code>命令在包内生成一个compress css的命令，我们执行的是<code>php artisan command:make CompressCssCommand --path=workbench/friparia/assetcompresser/src/Friparia/Assetcompresser</code></p>

<p>然后打开<code>workbench/vendor/package/src/commands/</code>文件夹中刚才生成的文件，按照上述加入namespace我们来设定我们这个命令和描述<br>
<code>php<br>
protected $name = &#39;compress:css&#39;;<br>
protected $description = &#39;Compress your css files to save your network traffic. No parameter means compress all css files in public/css in one file and &quot;--file&quot; means compress specify file&#39;;<br>
</code></p>

<p>这样当我们运行<code>php artisan</code>时我们就可以看到我们的命令以及说明了，然后完成<code>fire()</code>方法，我们先完成不加参数的方法(此时需要先将<code>getArguments()</code>和<code>getOptions()</code>两个方法注释掉)</p>

<p>```php<br>
    public function fire()<br>
    {<br>
        if($this-&gt;confirm(&#39;Compress all css files?[Yes/No]&#39;)){<br>
            $this-&gt;line(&#39;&#39;);<br>
            $this-&gt;info(&#39;compressing ...&#39;);<br>
            $cssdir = public<em>path().&#39;/css&#39;;<br>
            $compressed</em>filename = $cssdir.&#39;/&#39;.time().&#39;<em>compressed.min.css&#39;;<br>
            if(is</em>dir($cssdir)){<br>
                if($dh = opendir($cssdir)){<br>
                    $minified = &quot;&quot;;<br>
                    while($file = readdir($dh)){<br>
                        if($file != &#39;.&#39; &amp;&amp; $file != &#39;..&#39;){<br>
                            $path<em>parts = pathinfo($file);<br>
                            if($path</em>parts[&#39;extension&#39;] == &#39;css&#39;){<br>
                                $minified .= Assetcompresser::minifycss($cssdir.&#39;/&#39;.$file);<br>
                            }<br>
                        }<br>
                    }<br>
                    file<em>put</em>contents($compressed<em>filename, $minified);<br>
                    $this-&gt;line(&#39;&#39;);<br>
                    $this-&gt;info(&#39;css has compressed! The file&#39;.$compressed</em>filename.&#39; generated&#39;);<br>
                }else{<br>
                    $this-&gt;error(&#39;Cannot open &#39;.$cssdir);<br>
                }<br>
            }else{<br>
                $this-&gt;error($cssdir.&quot;does not exist&quot;);<br>
            }<br>
        }<br>
    }</p>

<p>```</p>

<p>我们有使用到<code>Assetcompresser::minifycss()</code>来压缩css，即我们这个包的功能，所以我们创建<code>Assetcompresser.php</code>文件，完成所需功能:</p>

<p>```php<br>
&lt;?php namespace Friparia\Assetcompresser;<br>
class Assetcompresser{<br>
    /**<br>
     * Minifies css files<br>
     * @param  string  $path  input css file<br>
     * @return string         compressed string<br>
     <em>/<br>
    static public function minifycss($path){<br>
        if(file<em>exists($path)){<br>
            if($contents = file</em>get<em>contents($path)){<br>
                $contents = trim($contents);<br>
                $contents = str</em>replace(&quot;\r\n&quot;, &quot;\n&quot;, $contents);<br>
                $search = array(&quot;/\/\</em>[\d\D]<em>?\</em>\/|\t+/&quot;, &quot;/\s+/&quot;, &quot;/}\s+/&quot;);<br>
                $replace = array(null, &quot; &quot;, &quot;}\n&quot;);<br>
                $contents = preg<em>replace($search, $replace, $contents);<br>
                $search = array(&quot;/\;\s/&quot;, &quot;/\s+{\s+/&quot;, &quot;/\:\s+\#/&quot;, &quot;/,\s+/i&quot;, &quot;/\:\s+\\&#39;/i&quot;, &quot;/\:\s+([0-9]+|[A-F]+)/i&quot;);<br>
                $replace = array(&quot;;&quot;, &quot;{&quot;, &quot;:#&quot;, &quot;,&quot;, &quot;:\&#39;&quot;, &quot;:$1&quot;);<br>
                $contents = preg</em>replace($search, $replace, $contents);<br>
                $contents = str_replace(&quot;\n&quot;, null, $contents);<br>
                return $contents;<br><br>
            }else{<br>
                return &quot;&quot;;<br>
            }</p>
<div class="highlight"><pre><code class="text">    }else{
        return &quot;&quot;;
    }
}
</code></pre>
</div>

<p>}<br>
```</p>

<p>最后别忘了在ServiceProvider里注册我们的命令，打开<code>AssetcompresserServiceProvider.php</code>，在<code>register()</code>方法中添加:<br>
<code>php<br>
        $this-&gt;app[&#39;command.compress.css&#39;] = $this-&gt;app-&gt;share(function($app){<br>
            return new CompressCssCommand($app);<br>
        });<br>
        $this-&gt;commands(<br>
            &#39;command.compress.css&#39;<br>
        );<br>
</code><br>
以使得我们的命令能够正确的被执行，执行<code>php artisan compress:css</code>就可以得到我们压缩后的css文件。</p>

<p>到此我们的不加参数的命令行的命令开发就完成了，在下一篇博客中我会把加参数的命令开发完成。并且利用空闲时间把这整个包完成~</p>
]]></content>
  </entry>
  
</feed>
